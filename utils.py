import numpy as np
import pandas as pd
import random


def read_data(csv_file, column_no, after_column):
    """
    Get the dataframe containing data from a csv file.

    Args:
        csv_file (str): a csv file
        column_no (int): start or end column of the dataset
        after_column (bool): true if it starts from that specific column,
                                otherwise false

    Returns:
        A dataframe containing the dataset
    """
    df = pd.read_csv(csv_file)
    if after_column:
        df = df.iloc[:, column_no:]
    else:
        df = df.iloc[:, :column_no]

    return df


def leave_subject(curr_df, n=1):
    """
    Random subject-wise dataset split.

    Args:
        curr_df: a dataframe
        n (int): number of subjects in the validation set

    Returns:
        Train and test dataframe with the randomly selected subject-ID
    """
    ids = []
    user_ids = np.unique(curr_df['userId'])
    for i in range(n):
        id = random.choice(user_ids)
        ids.append(id)
        indices = np.where(user_ids == id)
        user_ids = np.delete(user_ids, indices)
    test = curr_df[curr_df['userId'].isin(ids)]
    train = curr_df[~curr_df['userId'].isin(ids)]

    return train, test, ids


def custom_label_encode(data, mapping):
    """
    Mapping gesture-name to numeric values based on order

    Args:
        data (list): label data
        mapping (dictionary): pre-defined gesture mapping (e.g. 'circle'> 0)

    Returns:
        A list of encoded labels
    """
    encoded_labels = [mapping[item[0]] for item in data]

    return encoded_labels


def add_gestures(X_local, y_local, num_gestures):
    """
    Storing data and labels for specific gestures

    Args:
        X_local: data
        y_local: labels
        num_gestures (int): number of gestures

    Returns:
        A list of data and specific labels
    """
    X_n, y_n = [], []
    for i in range(len(y_local)):
        if y_local[i] in np.unique(y_local)[:num_gestures]:
            X_n.append(X_local[i])
            y_n.append(y_local[i])

    return X_n, y_n
